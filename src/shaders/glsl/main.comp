#version 450
#extension GL_GOOGLE_include_directive : require

#include "voxel.glsl"
#include "ray.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(set=1, binding = 0, rgba8) uniform writeonly image2D destImage;
layout(set=1, binding = 1, rg32ui) uniform readonly uimage2D indexImage;

layout(set = 0, binding = 0) buffer WorldInfo {
    vec4 posTime;
    vec2 cameraRot;
} worldInfo;

layout(set = 0, binding = 1) buffer Sizes {
    ivec3 occupancyMin;
    ivec3 occupancyMax;
    uint voxels;
    uint chunks;
} sizes;

layout(set = 0, binding = 2) buffer Voxels {
    uint data[];
} voxel;

layout(set = 0, binding = 3) buffer Chunks {
    Chunk data[];
} chunk;

layout(set = 0, binding = 4) buffer Occupancy {
    ChunkOccupancy data[];
} occupancy;

uint getVoxel(uint i) {
    uint data = voxel.data[i/2];
    data >>= 16*(i&1); // shift high bits if odd index
    return data&0xFFFF; // mask lower bits
}

vec2 getUV(ivec2 pos, ivec2 size) {
    float aspectRatio = float(size.x)/size.y;
    vec2 uv = vec2(pos)/size;
    uv *= 2;
    uv -= 1;
    uv.y *= -1;
    uv.x *= aspectRatio;
    return uv;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(destImage);
    if (pos.x >= imgSize.x || pos.y >= imgSize.y) return; // dont do pixels that are outside of the texture

    vec2 uv = getUV(pos, imgSize);

    vec3 dir = normalize(vec3(uv, 1.0));

    vec3 camPos = worldInfo.posTime.xyz;
    vec2 camRot = worldInfo.cameraRot;
    float time = worldInfo.posTime.w;

    // Quaternion for pitch
    vec4 qPitch = vec4(vec3(1.0, 0.0, 0.0) * sin(camRot.y*0.5), cos(camRot.y*0.5));

    // Quaternion for yaw
    vec4 qYaw = vec4(vec3(0.0, 1.0, 0.0) * sin(camRot.x*0.5), cos(camRot.x*0.5));

    // Combine into single rotation
    vec4 q = quatMultiply(qYaw, qPitch);
    dir = rotateVectorByQuat(dir, q);

    Ray ray = createRay(
        camPos,
        dir
    );

    uvec2 indexMap = imageLoad(indexImage, pos).rg;

    uint voxelIndex = indexMap.r;
    uint chunkIndex = indexMap.g;

    bool hit = (voxelIndex & (1u << 31)) != 0;
    voxelIndex &= ~(1u << 31); // remove hit bit from voxel index

    vec3 color = ray.dir;
    color = vec3(0.05); // get sky color

    if (hit) {
        // get the chunk
        Chunk c = chunk.data[chunkIndex];
        uint voxelData = getVoxel(c.index+voxelIndex);
        color = getVoxelColor(voxelData);
    }
    
    imageStore(destImage, pos, vec4(color.bgr, 1.0));
}