#version 450
#extension GL_GOOGLE_include_directive : require

#include "voxel.glsl"
#include "ray.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(set=1, binding = 0, rgba8) uniform writeonly image2D destImage;

layout(std430, set = 0, binding = 0) buffer WorldInfo {
    vec4 posTime;
    vec2 cameraRot;
} worldInfo;

layout(set = 0, binding = 1) buffer Sizes {
    int voxels;
    int chunks;
} sizes;

layout(set = 0, binding = 2) buffer Voxels {
    int data[];
} voxel;

layout(set = 0, binding = 3) buffer Chunks {
    Chunk data[];
} chunk;

int getVoxel(int i) {
    int data = voxel.data[i/2];
    data >>= 16*(i&1); // shift high bits if odd index
    return data&0xFFFF; // mask lower bits
}

Chunk getIntersectingChunk(Ray ray, out Intersection intersection) {
    Chunk closestChunk;
    Intersection closestIntersection;
    closestIntersection.near = 1e30; // start very far away
    closestIntersection.hit = false;

    for (int i = 0; i < sizes.chunks; i++) { // go through each chunk
        Chunk c = chunk.data[i];
        Box b = createBox(c.pos*c.size, c.size);
        Intersection intersection = intersectAABB(ray, b); // check its intersection
        if (intersection.hit && intersection.near < closestIntersection.near) { // if it hit and is closer than our closest found intersection
            closestIntersection = intersection;
            closestChunk = c;
        }
    } 

    intersection = closestIntersection;
    return closestChunk;
}

bool DDAVoxels(Chunk c, vec3 rayOrigin, float maxDist, vec3 rayDirection, out int data) {
    rayOrigin -= c.pos * c.size;          // bring ray into chunk space
    rayOrigin += rayDirection * 1e-3;     // nudge forward

    ivec3 voxel = ivec3(floor(rayOrigin));
    vec3 step = sign(rayDirection);       // +1 or -1

    // branchless tMax computation
    vec3 tMax = ((vec3(voxel) + step * 0.5 + 0.5) - rayOrigin) / rayDirection;
    vec3 tDelta = abs(1.0 / rayDirection);

    float traveled = 0.0;

    for (;;) {
        // bounds check (can also be precomputed with clamp)
        bvec3 inBounds = bvec3(
            voxel.x >= 0 && voxel.x < c.size.x,
            voxel.y >= 0 && voxel.y < c.size.y,
            voxel.z >= 0 && voxel.z < c.size.z
        );
        if (!all(inBounds) || traveled > maxDist)
            return false;

        int index = c.index + voxel.x + voxel.y * c.size.x + voxel.z * c.size.x * c.size.y;
        data = getVoxel(index);
        if (isVoxelSolid(data))
            return true;

        // branchless: find axis with minimum tMax
        float tMin = min(min(tMax.x, tMax.y), tMax.z);
        // step voxel along min axis
        voxel.x += int(step.x * float(tMax.x == tMin));
        voxel.y += int(step.y * float(tMax.y == tMin));
        voxel.z += int(step.z * float(tMax.z == tMin));
        traveled = tMin;
        tMax += vec3(tMax.x == tMin ? tDelta.x : 0.0,
                     tMax.y == tMin ? tDelta.y : 0.0,
                     tMax.z == tMin ? tDelta.z : 0.0);
    }
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(destImage);
    if (pos.x >= imgSize.x || pos.y >= imgSize.y) return; // dont do pixels that are outside of the texture

    float aspectRatio = float(imgSize.x)/imgSize.y;
    
    vec2 uv = vec2(pos)/imgSize;
    uv *= 2;
    uv -= 1;
    uv.y *= -1;
    uv.x *= aspectRatio;

    vec3 dir = normalize(vec3(uv, 1.0));

    vec3 camPos = worldInfo.posTime.xyz;
    vec2 camRot = worldInfo.cameraRot;
    float time = worldInfo.posTime.w;

    // Quaternion for pitch (X-axis)
    vec4 qPitch = vec4(vec3(1.0, 0.0, 0.0) * sin(camRot.y*0.5), cos(camRot.y*0.5));

    // Quaternion for yaw (Y-axis)
    vec4 qYaw = vec4(vec3(0.0, 1.0, 0.0) * sin(camRot.x*0.5), cos(camRot.x*0.5));

    // Combine into single rotation
    vec4 q = quatMultiply(qYaw, qPitch);
    dir = rotateVectorByQuat(dir, q);

    Ray ray = createRay(
        camPos,
        dir
    );

    vec3 color = ray.dir;

    Intersection intersection;
    Chunk c;
    bool hit;
    int data;
    while (true) {
        c = getIntersectingChunk(ray, intersection);
        if (!intersection.hit) break; // if no chunk intersections found leave the loop

        hit = DDAVoxels(c, ray.pos+ray.dir*intersection.near, intersection.far-intersection.near, ray.dir, data);
        if (hit) { // if a voxel is hit leave the loop
            color = getVoxelColor(data);
            break;
        }
        ray.pos += ray.dir * intersection.far + ray.dir * 1e-5;
    }
    
    imageStore(destImage, pos, vec4(color, 1.0));
}