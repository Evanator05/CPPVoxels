#version 450
#extension GL_GOOGLE_include_directive : require

#include "voxel.glsl"
#include "ray.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(set=1, binding = 0, rg32ui) uniform writeonly uimage2D destImage;
layout(set=1, binding = 1, r32f) uniform readonly image2D depthImage;

layout(set = 0, binding = 0) buffer WorldInfo {
    vec4 posTime;
    vec2 cameraRot;
} worldInfo;

layout(set = 0, binding = 1) buffer Sizes {
    ivec3 occupancyMin;
    ivec3 occupancyMax;
    uint voxels;
    uint chunks;
} sizes;

layout(set = 0, binding = 2) buffer Voxels {
    uint data[];
} voxel;

layout(set = 0, binding = 3) buffer Chunks {
    Chunk data[];
} chunk;

layout(set = 0, binding = 4) buffer Occupancy {
    ChunkOccupancy data[];
} occupancy;

layout(set = 0, binding = 5) buffer Visibility {
    uint data[];
} visibility;

uint getVoxel(uint i) {
    uint data = voxel.data[i >> 1];
    data >>= 16*(i&1); // shift high bits if odd index
    return data&0xFFFF; // mask lower bits
}

bool getVisiblility(uint i) {
    uint page = visibility.data[i >> 5];
    uint mask = 1u << (i & 31u);
    return (page&mask) != 0u;
}

void setVisiblility(uint i) {
    uint mask = 1u << (i & 31u);
    uint pageIndex = i >> 5;
    atomicOr(visibility.data[pageIndex], mask);
}

void clearVisiblility(uint i) {
    uint mask = 1u << (i & 31u);
    uint pageIndex = i >> 5;
    atomicAnd(visibility.data[pageIndex], ~mask);
}

bool DDAVoxels(Chunk c, Ray ray, out uint voxelIndex) {
    ray.pos -= c.pos * c.size; // bring ray into chunk space
    ray.pos += sign(ray.dir) * 1e-3; // nudge forward

    ivec3 voxel = ivec3(floor(ray.pos));
    vec3 step = sign(ray.dir);

    // branchless tMax computation
    vec3 tMax = ((vec3(voxel) + step * 0.5 + 0.5) - ray.pos) / ray.dir;
    vec3 tDelta = abs(1.0 / ray.dir);

    while (voxel.x >= 0 && voxel.x < CHUNKWIDTH &&
            voxel.y >= 0 && voxel.y < CHUNKWIDTH &&
            voxel.z >= 0 && voxel.z < CHUNKWIDTH) {

        uint index = voxel.x +
                     voxel.y * CHUNKWIDTH +
                     voxel.z * CHUNKWIDTH * CHUNKWIDTH;
        
        uint data = getVoxel(c.index + index);
        if (isVoxelSolid(data)) {
            voxelIndex = uint(index);
            return true;
        }

        // find axis with minimum tMax
        float tMin = min(min(tMax.x, tMax.y), tMax.z);
        // step voxel along min axis
        ivec3 stepMask = ivec3(
            tMax.x == tMin,
            tMax.y == tMin,
            tMax.z == tMin
        );

        voxel += ivec3(step)*stepMask;

        tMax += vec3(
            stepMask.x != 0 ? tDelta.x : 0.0,
            stepMask.y != 0 ? tDelta.y : 0.0,
            stepMask.z != 0 ? tDelta.z : 0.0
        );
    }
    return false;
}

bool DDAChunks(Ray ray, out uint voxelIndex, out uint chunkIndex) {
    ivec3 gridSize = sizes.occupancyMax - sizes.occupancyMin + ivec3(1);
    Box occupancyVolume = createBox(sizes.occupancyMin * CHUNKWIDTH, gridSize * CHUNKWIDTH);
    Intersection occHit = intersectAABB(ray, occupancyVolume);
    if (!occHit.hit) return false;

    vec3 step = sign(ray.dir);
    const float CHUNK_SIZE = float(CHUNKWIDTH);
    float eps = 1e-6;

    vec3 rayStart = ray.pos + ray.dir * occHit.near + eps * step;

    // world-space chunk coordinates
    ivec3 chunkPos = ivec3(floor(rayStart / CHUNK_SIZE));

    // compute nextBoundary per-axis depending on step
    vec3 nextBoundary;
    nextBoundary.x = step.x > 0.0 ? float(chunkPos.x + 1) * CHUNK_SIZE : float(chunkPos.x) * CHUNK_SIZE;
    nextBoundary.y = step.y > 0.0 ? float(chunkPos.y + 1) * CHUNK_SIZE : float(chunkPos.y) * CHUNK_SIZE;
    nextBoundary.z = step.z > 0.0 ? float(chunkPos.z + 1) * CHUNK_SIZE : float(chunkPos.z) * CHUNK_SIZE;

    vec3 tMax = (nextBoundary - rayStart) / ray.dir;
    vec3 tDelta = abs(CHUNK_SIZE / ray.dir);

    float traveled = 0.0;

    while (true) {
        ivec3 gridPos = chunkPos - sizes.occupancyMin;
        if (gridPos.x < 0 || gridPos.x >= gridSize.x ||
            gridPos.y < 0 || gridPos.y >= gridSize.y ||
            gridPos.z < 0 || gridPos.z >= gridSize.z)
            break;

        int occIndex = gridPos.x + gridPos.y * gridSize.x + gridPos.z * gridSize.x * gridSize.y;
        ChunkOccupancy occ = occupancy.data[occIndex];

        if ((occ.flags & CHUNKFLAGS_EMPTY) != 0) {
            Chunk c = chunk.data[occ.index];
            if (DDAVoxels(c, Ray(rayStart + ray.dir * traveled, ray.dir), voxelIndex)) {
                chunkIndex = occ.index;
                return true;
            }
        }

        float tMin = min(min(tMax.x, tMax.y), tMax.z);
        ivec3 stepMask = ivec3(
            tMax.x == tMin,
            tMax.y == tMin,
            tMax.z == tMin
        );

        chunkPos += stepMask * ivec3(step);
        traveled = tMin;
        tMax += vec3(
            stepMask.x != 0 ? tDelta.x : 0.0,
            stepMask.y != 0 ? tDelta.y : 0.0,
            stepMask.z != 0 ? tDelta.z : 0.0
        );
    }

    return false;
}



vec2 getUV(ivec2 pos, ivec2 size) {
    float aspectRatio = float(size.x)/size.y;
    vec2 uv = vec2(pos)/size;
    uv *= 2;
    uv -= 1;
    uv.y *= -1;
    uv.x *= aspectRatio;
    return uv;
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(destImage);
    if (pos.x >= imgSize.x || pos.y >= imgSize.y) return; // dont do pixels that are outside of the texture

    vec2 uv = getUV(pos, imgSize);

    vec3 dir = normalize(vec3(uv, 1.0));

    vec3 camPos = worldInfo.posTime.xyz;
    vec2 camRot = worldInfo.cameraRot;
    float time = worldInfo.posTime.w;

    // Quaternion for pitch
    vec4 qPitch = vec4(vec3(1.0, 0.0, 0.0) * sin(camRot.y*0.5), cos(camRot.y*0.5));

    // Quaternion for yaw
    vec4 qYaw = vec4(vec3(0.0, 1.0, 0.0) * sin(camRot.x*0.5), cos(camRot.x*0.5));

    // Combine into single rotation
    vec4 q = quatMultiply(qYaw, qPitch);
    dir = rotateVectorByQuat(dir, q);

    Ray ray = createRay(
        camPos,
        dir
    );

    float depth = imageLoad(depthImage, pos).r;
    ray.pos += ray.dir*depth;
    vec3 color = vec3(0);

    uint chunkIndex;
    uint voxelIndex;
    bool hit = DDAChunks(ray, voxelIndex, chunkIndex);
    voxelIndex |= (1<<31) * int(hit);
    if (!hit) {
        chunkIndex = 0;
        voxelIndex = 0;
    }
    imageStore(destImage, pos, uvec4(voxelIndex, chunkIndex, 0u, 0u));
}